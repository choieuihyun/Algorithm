        7
      3   8
    8   1   0
  2   7   4   4
4   5   2   6   5

이렇게 입력 받아서 아래로 내려오며 더하면서 최댓값을 구해라. but 왼쪽 대각선, 오른쪽 대각선으로 밖에 못움직임.

사실 이건 쉬운문제로 보인다. 내가 풀지는 모르겠는데.

층층이 찾아가는거라 어려워 보이지만 배열 하나에 다 저장하고 인덱스 0에 맨 처음값 주입.

그 뒤에 인덱스 1부터 숫자 두개, 세개, 네개, 다섯개 늘려가면서 연속합 문제처럼 잘라가면서 최댓값을 구해서 메모이제이션 사용.

이 방법으로 푼다고 생각하면 그 다음 생각할 문제.

0 / 1,2 / 3,4,5 / 6,7,8,9 / 10,11,12,13,14 순서대로 어떻게 탐색할꺼임. 그걸 코드로 구현해야함. 이라고 생각했는데 아니네?
이렇게 하면 왼쪽 대각선 오른쪽 대각선으로만 움직일 수 있다는 규칙에 위배되어버리고 만다.

위의 그림 기반으로 다시 생각해보자.

					[0] = 7 -> [0]은 [1], [2] 중에서 탐색. -> 1, 2 차이나는 인덱스.
					
				[1] = 3 [2] = 8 -> [1]은 [3],[4] 중에서 탐색, [2]는 [4],[5] 중에서 탐색. -> 2, 3 차이나는 인덱스.
				
			[3] = 8 [4] = 1 [5] = 0 -> [3]은 [6],[7] 중에서 탐색, [4]는 [7],[8]중에서 탐색, [5]는 [8],[9]중에서 탐색. -> 3, 4 차이나는 인덱스.
			
		[6] = 2 [7] = 7 [8] = 4 [9] = 4 -> [6]은 [10],[11] 중에서 탐색 등등. -> 4, 5 차이나는 인덱스.
		
  [10] = 4 [11] = 4 [12] = 2 [13] = 6 [14] = 5 그럼 [10]은 [15],[16] 중에서 탐색이겠지 뭐. -> 5, 6 차이나는 인덱스.
  
  
아니다 관점 폐지. 위의 관점은 배열을 1차원으로 쓰는 경우였는데 아닌 것 같음.

2차원 배열로 생각해야할듯.
