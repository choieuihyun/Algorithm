계단 수 찾기

계단 수란? : 인접한 모든 자리의 차이가 1인 경우
		   ex) 45656은 계단 수.
		   
N이 자연수일 때, 길이가 N인 계단 수가 몇 개 인지 구해보자.

* 풀고 난 후 깨달은점

bottom-up(for)로 바꿀 때 점화식 안세우면 평생 봐도 모른다.

--------------------------------------------------------

이거 그 자릿수 계산이랑 같은 원리라고 생각됨.

10으로 나머지 연산해서 자릿수마다 비교하는 원리라고 보인다.

그렇다면 내가 dp 정의를 내린 것 처럼 계단 수의 갯수가 dp[]에 들어갈 것이고

그에 따른 조건을 점화식으로만 세우면 문제가 이론 상으론 해결됨.

그럼 점화식을 생각해보자 (0은 제외)

한자리 수면 1,2,3,4,5,6,7,8,9 이렇게 9개의 계단 수가 존재함.
두자리 수면 10, 12, 21, 23, 32, 34, 43, 45, 54, 56, 65, 67, 76, 78
		 87, 89, 98
		 
세자리는 너무 방대해서 안되고

자릿 수 만큼의 수를 생성해서 그 안에서 하나씩 일일히 나머지 연산 돌려가면서 1차이 날때
dp에 + 1 이런 구조인가?

여기서 생각해야하는게 내가 입력하는 수는 N 하나 뿐이고 이건 계단 수의 길이임.
그러면 내가 생각해야할 것은 이 수를 가지고 어떻게 저 숫자를 활용해서 풀 것인가?

----------------------------------------------------------

자릿수 생각을 할때 헷갈리면 안되는게 소수와 자연수의 차이가 있음.

소수는 1.23456 하면 2가 첫째 자릿수인데
자연수는 123456 하면 6이 첫째 자릿수임.

그래서 생각을 할 때 둘째 자리에 2일때로 생각하면 21, 23을 생각했어야하고
0은 다음 수가 1, 9는 다음 수가 8, 나머지는 +-1로 가능하단 것을 파악했어야함.

* 헷갈릴 수 있는 부분
find(2,0)을 넣었을 때를 생각해보면 둘째 자릿수가 0이라는건데
그러면 01, 02 이런 식으로 되는거 아니에요? 라고 생각 가능함.
근데 이거는 내가 애초에 result에 더할 때 value 범위 자체가 1부터 시작임.
